# 简明教程

## 基础语法

- 变量
- 常量和不可变量的区别

## 数据类型

- 整型
- 浮点型
- 布尔型
- 字符型
- 复合类型
  - 元组 ()
  - 数组 []

## 循环

- while
- for
- loop = (while(true))

## 所有权

- 变量和数据交互的方式
  - 移动
  - 克隆
- 函数所有权
- 函数返回值所有权
- 引用
- 借用
- 垂悬引用

## 切片

- 字符串切片
- 非字符串切片(线性结构,如数组)

## 结构体

- 元组结构体
- 结构体方法
- 结构体关联函数(没有 self,一般用于构造函数)
- 单元结构体(struct type; 没有结构体字段)

## 枚举类

- match 语法
- Option 枚举类
- if let 语法

## 包管理

### 箱

二进制文件或库文件,一个包最多包含一个库箱,可以包含任意个二进制箱,但至少包含一个箱.

### 包

src/main.rs 默认是二进制箱的根,编译后的二进制箱与包同名

### 模块

rust 中的路径分隔符为`::`,相当于 Linux 文件系统的`/`,以树状组织代码.

```rust
mod nation {
    mod government {
        fn govern() {}
    }
    mod congress {
        fn legislate() {}
    }
    mod court {
        fn judicial() {}
    }
}
```

路径分为绝对路径和相对路径.绝对路径从 crate 关键字开始描述.相对路径从 self 或 super 关键字或一个标识符开始描述.

```rust
crate::nation::government::govern(); // 绝对路径
nation::government::govern(); // 相对路径
```

### 访问权限

默认情况下,模块中的成员访问权将是私有的.只有在与其平级的位置或下级的位置才能访问.如果模块中定义了结构体,结构体除了其本身是私有的以外,其字段也默认是私有的.枚举类枚举项可以内含字段,但不具备类似的性质.

### 难以发现的模块

文件名就是模块名.

```rust
// main.rs
mod second_module;
fn main() {
    println!("This is the main module.");
    println!("{}", second_module::message());
}
// second_module.rs
pub fn message() -> String {
    String::from("This is the 2nd module.")
}
```

### use

使用 as 关键字为标识符添加别名.

### 引用标准库

所有的系统库模块都是被默认导入的,只需要使用 use 关键字简化路径就可以使用了.

```rust
use std::f64::consts::PI;
fn main() {
    println!("{}", (PI / 2.0).sin());
}
```

## 错误处理

### 可恢复错误

可恢复错误用 `Result<T, E>` 类来处理.

```rust
// 枚举类
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");
    match f {
        Ok(file) => {
            println!("File opened successfully.");
        },
        Err(err) => {
            println!("Failed to open the file.");
        }
    }
    // if let 写法
    if let Ok(file) = f {
        println!("File opened successfully.");
    } else {
        println!("Failed to open the file.");
    }
}
```

如果想使一个可恢复错误按不可恢复错误处理,Result 类提供了两个办法:unwrap() 和 expect(message: &str):

```rust
// 相当于在 Result 为 Err 时调用 panic! 宏
let f1 = File::open("hello.txt").unwrap();
let f2 = File::open("hello.txt").expect("Failed to open.");
```

#### 可恢复错误传递

? 符的实际作用是将 Result 类非异常的值直接取出.如果有异常就将异常 Result 返回出去.? 符仅用于返回值类型为 `Result<T, E>` 的函数,其中 E 类型必须和 ? 所处理的 Result 的 E 类型一致.

```rust
fn f(i: i32) -> Result<i32, bool> {
    if i >= 0 { Ok(i) }
    else { Err(false) }
}

fn g(i: i32) -> Result<i32, bool> {
    let t = f(i)?;
    Ok(t) // 因为确定 t 不是 Err,t 在这里已经是 i32 类型
}

fn main() {
    let r = g(10000);
    if let Ok(v) = r {
        println!("Ok: g(10000) = {}", v);
    } else {
        println!("Err");
    }
}
```

### kind 方法

### 不可恢复错误

不可恢复错误使用 `panic!` 宏来处理.

```shell
RUST_BACKTRACE=1 cargo run
```

## 泛型与特性

- 在函数中定义泛型
- 结构体与枚举类中的泛型
- 特性
- 默认特性
- 特性做参数
- 特性做返回值
- 有条件实现方法

## 声明周期

- 生命周期注释
- 结构体中使用字符串切片引用
- 静态生命周期
- 泛型、特性与生命周期协同作战

## 文件与 io

- 接收命令行参数
- 命令行输入
- 文件读取
- 文件写入

## 集合与字符串

- Vector
- 字符串
- Map

## 小结

- `#[derive(Debug)]`
- crate 是 Rust 中最小的编译单元, package 是单个或多个 crate 的集合
- 你会在许多类型上发现 new 函数,因为这是创建类型实例的惯用函数名称.
- Rust 中的包(crate)代表了一系列源代码文件的集合
- Rust 对于整数字面量的默认推导类型 i32
- usize 和 isize 则主要用作某些集合的索引.
- 实希望显式地进行环绕行为,那么你可以使用标准库中的类型 Wrapping
- 默认会将浮点数字面量的类型推导为 f64
- f32 和 f64 类型分别对应着标准中的单精度浮点数和双精度浮点数
- char 类型占 4 字节,是一个 Unicode 标量值
- 语句指那些执行操作但不返回值的指令,表达式则是指会进行计算并产生一个值作为结果的指令,语句不会返回值
- 默认返回了 一个空元组,也就是上面描述中的()
