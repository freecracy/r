# 常见概念

## 基本类型

当多种类型均有可能时,必须增加类型注解.

### 标量

#### 整型

| 长度    | 有符号  | 无符号  |
| ------- | ------- | ------- |
| 8-bit   | `i8`    | `u8`    |
| 16-bit  | `i16`   | `u16`   |
| 32-bit  | `i32`   | `u32`   |
| 64-bit  | `i64`   | `u64`   |
| 128-bit | `i128`  | `u128`  |
| arch    | `isize` | `usize` |

每一个有符号的变体可以储存包含从 -(2^n - 1) 到 2^(n - 1)- 1 在内的数字.无符号的变体可以储存从 0 到 2^n - 1 的数字.isize 和 usize 类型依赖运行程序的计算机架构:64 位架构上它们是 64 位的, 32 位架构上它们是 32 位的.注意除 byte 以外的所有数字字面值允许使用类型后缀,例如 57u8,同时也允许使用 `_` 做为分隔符以方便读数,例如 1_000.

| 数字字面值                    | 例子          |
| ----------------------------- | ------------- |
| Decimal (十进制)              | `98_222`      |
| Hex (十六进制)                | `0xff`        |
| Octal (八进制)                | `0o77`        |
| Binary (二进制)               | `0b1111_0000` |
| Byte (单字节字符)(仅限于`u8`) | `b'A'`        |

数字类型默认是 i32:它通常是最快的,甚至在 64 位系统上也是.isize 或 usize 主要作为某些集合的索引.

##### 整型溢出

1. 当在 debug 模式编译时,Rust 检查这类问题并使程序 panic
2. 在 release 构建中,Rust 不检测溢出,相反会进行一种被称为二进制补码包装,256 变成 0，257 变成 1,依此类推

#### 浮点型

浮点数类型是 f32 和 f64，分别占 32 位和 64 位。默认类型是 f64.现代 CPU 中,它与 f32 速度几乎一样,不过精度更高.浮点数采用 IEEE-754 标准表示,f32 是单精度浮点数,f64 是双精度浮点数.

```rust
let y: f32 = 3.0;
```

##### 数值运算

```rust
let sum = 5 + 10;            // 加法
let difference = 95.5 - 4.3; // 减法
let product = 4 * 30;        // 乘法
let quotient = 56.7 / 32.2;  // 除法
let remainder = 43 % 5;      // 取余
```

#### 布尔类型

```rust
let t = true;
let f: bool = false; // 显式指定类型注解
```

#### 字符类型

char 类型是语言中最原生的字母类型.char 类型的大小为四个字节,并代表了一个 Unicode 标量值,比 ASCII 表示更多内容.

```rust
let c = 'z';
let z = 'ℤ';
let heart_eyed_cat = '😻';
```

### 复合

#### 元组

元组是一个将多个其他类型的值组合进一个复合类型的主要方式,元组长度固定:一旦声明，其长度不会增大或缩小.我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型.

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
```

为了从元组中获取单个值,可以使用模式匹配来解构元组值.

```rust
let tup = (500, 6.4, 1);
let (x, y, z) = tup; // 解构
```

也可以使用点号（.）后跟值的索引来直接访问它们.

```rust
let x: (i32, f64, u8) = (500, 6.4, 1);
let five_hundred = x.0;
let six_point_four = x.1;
let one = x.2;
```

#### 数组

与元组不同,数组中的每个元素的类型必须相同,数组是固定长度的:一旦声明,它们的长度不能增长或缩小.数组中的值位于中括号内的逗号分隔的列表中,

作用 :

1. 在栈而不是在堆上为数据分配
2. 想要确保总是有固定数量的元素

```rust
let a = [1, 2, 3, 4, 5];
```

1. 元组 : 小括号
2. 数组 : 大括号

编写数组的类型:在方括号中包含每个元素的类型,后跟分号,再后跟数组元素的数量.

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

如果要为每个元素创建包含相同值的数组,可以指定初始值,后跟分号,然后在方括号中指定数组的长度.

```rust
let a = [3; 5];
```

##### 访问数组元素

数组是一整块分配在栈上的内存,可以使用索引来访问数组的元素.

```rust
let a = [1, 2, 3, 4, 5];
let first = a[0];
let second = a[1];
```

##### 无效的数组元素访问

可以编译通过,不过在运行时会因错误而退出.当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度.如果索引超出了数组长度,Rust 会 panic.

##### vector 类型

vector 类型是标准库提供的一个允许增长和缩小长度的类似数组的集合类型.当不确定是应该使用数组还是 vector 的时候,你可能应该使用 vector.

## 类型注解

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

## 常量

常量不光默认不能变,它总是不能变.声明常量必须注明值的类型.常量的命名规范是使用下划线分隔的大写字母单词,并且可以在数字字面值中插入下划线来提升可读性.

```rust
const MAX_POINTS: u32 = 100_000;
```

## 变量

变量默认是不可改变的.使用大型数据结构时,适当地使用可变变量,可能比复制和返回新分配的实例更快,对于较小的数据结构,总是创建新实例,采用更偏向函数式的编程风格,可能会使代码更易理解,为可读性而牺牲性能或许是值得的.

```rust
let mut x = 5; // let 默认不可变,mut 允许改变值之外,其他代码将会改变这个变量值的意图
```

### 隐藏

可以用相同变量名称来隐藏一个变量,以及重复使用 let 关键字来多次隐藏.

1. 当不小心尝试对变量重新赋值时,如果没有使用 let 关键字,就会导致编译时错误
2. 通过使用 let,我们可以用这个值进行一些计算,不过计算完之后变量仍然是不变的
3. 当再次使用 let 时,实际上创建了一个新变量,我们可以改变值的类型,但复用这个名字
4. 隐藏使我们不必使用不同的名字,可以复用变量名

## 函数

函数和变量名使用 snake case 规范风格,所有字母都是小写并使用下划线分隔单词.Rust 不关心函数定义于何处,只要定义了就行.

```rust
fn another_function() {
    println!("Another function.");
}
```

在函数签名中,必须声明每个参数的类型.要求在函数定义中提供类型注解,意味着编译器不需要你在代码的其他地方注明类型来指出你的意图.

```rust
fn another_function(x: i32, y: i32) {
    println!("The value of x is: {}", x);
    println!("The value of y is: {}", y);
}
```

Rust 是一门基于表达式的语言.

1. 语句: 是执行一些操作但不返回值的指令
2. 表达式 : 计算并产生一个值

函数调用是一个表达式,宏调用是一个表达式,我们用来创建新作用域的大括号(代码块),{},也是一个表达式.

```rust
let y = {
    let x = 3;
    x + 1 // 达式的结尾没有分号,如果在表达式的结尾加上分号,它就变成了语句而语句不会返回值
};
```

### 具有返回值的函数

不对返回值命名,但要在箭头(->)后声明它的类型,函数的返回值等同于函数体最后一个表达式的值.

```rust
fn five() -> i32 {
    5
}
```

## 控制流

### if

```rust
let number = 6;
if number % 4 == 0 {
    println!("number is divisible by 4");
} else if number % 3 == 0 {
    println!("number is divisible by 3");
} else if number % 2 == 0 {
    println!("number is divisible by 2");
} else {
    println!("number is not divisible by 4, 3, or 2");
}
```

#### 在 let 语句中使用 if

```rust
let condition = true;
let number = if condition {
    5
} else {
    6
};
```

### 循环

#### loop

```rust
let mut counter = 0;
let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2;
    }
};
```

#### while

```rust
let mut number = 3;
while number != 0 {
    println!("{}!", number);
    number = number - 1;
}
```

#### while 遍历集合

```rust
let a = [10, 20, 30, 40, 50];
let mut index = 0;
while index < 5 {
    println!("the value is: {}", a[index]);
    index = index + 1;
}
```

1. 这个过程很容易出错,如果索引长度不正确会导致程序 panic
2. 这也使程序更慢,编译器增加了运行时代码来对每次循环的每个元素进行条件检查,比如数组移除元素没有修改 while 会 panic

#### for

```rust
for number in (1..4).rev() {
    println!("{}!", number);
}

let a = [10, 20, 30, 40, 50];
for i in 0..5 {
    println!("{0}, {0}", i);
}
for i in a.iter() {
    println!("{}", i);
}
```

## 注释

```rust
// hello, world
```

## 关键字

## 问题

### 错误赋值

```rust
x = y = 6 // rust 不支持这样赋值
```

### if 返回值类型

```rust
// 类型不匹配
// if 和 else 分支的值类型是不相容的
let number = if condition {
    5
} else {
    "six"
};
```
