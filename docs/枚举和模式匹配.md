# 枚举和模式匹配

## 枚举

举允许你通过列举可能的成员来定义一个类型.

### 定义枚举

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

### 枚举值

枚举的成员位于其标识符的命名空间中,并使用两个冒号分开.这么设计的益处是现在 IpAddrKind::V4 和 IpAddrKind::V6 都是 IpAddrKind 类型的.

```rust
enum IpAddrKind {
    V4,
    V6,
}
struct IpAddr {
    kind: IpAddrKind,
    address: String,
}
let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};
let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

### 数据附加到枚举的每个成员

用枚举替代结构体还有另一个优势:每个成员可以处理不同类型和数量的数据.

```rust
enum IpAddr {
    V4(String),
    V6(String),
}
let home = IpAddr::V4(String::from("127.0.0.1"));
let loopback = IpAddr::V6(String::from("::1"));
```

#### 将任意类型的数据放入枚举成员中

```rust
enum IpAddr {
    V4(u8, u8, u8, u8), // 参见标准库是实现,可以存储结构体
    V6(String),
}
let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from("::1"));
```

#### 每个成员都存储了不同数量和类型的值

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
// 等价结构体
struct QuitMessage; // 类单元结构体
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 元组结构体
struct ChangeColorMessage(i32, i32, i32); // 元组结构体
```

### Option 枚举

编程语言的设计经常要考虑包含哪些功能,但考虑排除哪些功能也很重要.Rust 并没有很多其他语言中有的空值功能,空值(Null)是一个值,它代表没有值.在有空值的语言中,变量总是这两种状态之一:空值和非空值.

Rust 并没有空值,不过它确实拥有一个可以编码存在或不存在概念的枚举.这个枚举是 `Option<T>`,而且它定义于标准库中.

```rust
enum Option<T> {
    Some(T),
    None,
}
```

包含在了 prelude 之中,你不需要将其显式引入作用域.另外,它的成员也是如此,可以不需要 `Option::` 前缀.

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y; // panic
```

在对 `Option<T>` 进行 T 的运算之前必须将其转换为 T,通常这能帮助我们捕获到空值最常见的问题之一:假设某值不为空但实际上为空的情况.

为了使用 `Option<T>` 值,需要编写处理每个成员的代码,你想要一些代码只当拥有 `Some(T)` 值时运行,允许这些代码使用其中的 T.也希望一些代码在值为 None 时运行,这些代码并没有一个可用的 T 值.match 表达式就是这么一个处理枚举的控制流结构:它会根据枚举的成员运行不同的代码,这些代码可以使用匹配到的值中的数据.

## match

match 表达式中用模式匹配,针对不同的枚举值编写相应要执行的代码.允许我们将一个值与一系列的模式相比较,并根据相匹配的模式执行相应代码.模式可由字面值、变量、通配符和许多其他内容构成.match 的力量来源于模式的表现力以及编译器检查,它确保了所有可能的情况都得到处理.

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1, // => 分隔模式和代码
        Coin::Nickel => 5, // , 分隔分支
        Coin::Dime => 10,
        Coin::Quarter => {
            println!("Lucky penny!");
            25
        }, // 大括号运行多行代码
    }
}
```

### `匹配 Option<T>`

我们在之前的部分中使用 `Option<T>` 时,是为了从 Some 中取出其内部的 T 值.

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

- 匹配 `Some(T)`
- 匹配是穷尽的: 必须穷举到最后的可能性来使代码有效

## `_` 通配符

Rust 也提供了一个模式用于不想列举出所有可能值的场景,可以使用特殊的模式 `_` 替代.

```rust
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}
```

## if let

if let 语法让我们以一种不那么冗长的方式结合 if 和 let，来处理只匹配一个模式的值而忽略其他模式的情况.使用 if let 意味着编写更少代码,更少的缩进和更少的样板代码.然而,这样会失去 match 强制要求的穷尽性检查.可以认为 if let 是 match 的一个语法糖,它当值匹配某一模式时执行代码而忽略所有其他值.

```rust
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
```
