# 结构体

## 定义并实例化结构体

基于结构体和枚举可以创建新类型.结构体需要命名各部分数据以便能清楚的表明其值的意义.由于有了这些名字,结构体比元组更灵活:不需要依赖顺序来指定或访问实例中的值.

### 定义结构体

```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
```

### 创建实例

```rust
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
user1.email = String::from("anotheremail@example.com"); // 整个实例必须是可变的;Rust 并不允许只将某个字段标记为可变
```

### 字段初始化简写语法

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
```

### 结构体更新语法

```rust
let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1
};
```

### 元组结构体

也可以使用 `.` 后跟索引来访问单独的值.

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0); //每一个结构体有其自己的类型,即使结构体中的字段有着相同的类型,black 和 origin 值的类型不同
```

### 类单元结构体

类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据.

## 结构体数据的所有权

可以使结构体存储被其他对象拥有的数据的引用,不过这么做的话需要用上生命周期.生命周期确保结构体引用的数据有效性跟结构体本身保持一致.如果你尝试在结构体中存储一个引用而不指定生命周期将是无效的.

```rust
struct User {
    username: &str, //使用了自身拥有所有权的 String 类型而不是 &str 字符串 slice 类型
    email: &str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: "someone@example.com",
        username: "someusername123",
        active: true,
        sign_in_count: 1,
    };
}
```

## 通过派生 trait 增加实用功能

println! 宏能处理很多类型的格式,不过，`{}` 默认告诉 println! 使用被称为 Display 的格式:意在提供给直接终端用户查看的输出.目前为止见过的基本类型都默认实现了 Display,因为它就是向用户展示或其他任何基本类型的唯一方式.结构体并没有提供一个 Display 实现.

`println!("rect1 is {:?}", rect1);` 在 `{}` 中加入 `:?` 指示符告诉 println! 我们想要使用叫做 Debug 的输出格式,Debug 是一个 trait,它允许我们以一种对开发者有帮助的方式打印结构体,以便当我们调试代码时能看到它的值.

Rust 确实包含了打印出调试信息的功能,不过我们必须为结构体显式选择这个功能.在结构体定义之前加上 `#[derive(Debug)]` 注解.

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("rect1 is {:?}", rect1); // 可以使用 {:#?} 替换 println! 字符串中的 {:?}, 格式化输出
}
```

## 方法

方法与函数不同,它们在结构体的上下文、枚举或 trait 对象的上下文中被定义,并且它们第一个参数总是 self,它代表调用该方法的结构体实例.

### 定义方法

每个结构体都允许拥有多个 impl 块,但每个方法有其自己的 impl 块.

```rust
impl Rectangle {
    fn area(&self) -> u32 { //想要在方法中改变调用方法的实例  &mut self
        self.width * self.height
    }
}
```

### 自动引用和解引用

在 C/C++ 语言中,有两个不同的运算符来调用方法: `.` 直接在对象上调用方法，而 `->` 在一个对象的指针上调用方法,这时需要先解引用（dereference）指针.换句话说,如果 object 是一个指针,那么 `object->something()` 就像 `(*object).something()` 一样.

当使用 `object.something()` 调用方法时，Rust 会自动为 object 添加 `&`、`&mut` 或 `*` 以便使 object 与方法签名匹配.

```rust
p1.distance(&p2);
(&p1).distance(&p2);
```

这种自动引用的行为之所以有效，是因为方法有一个明确的接收者 self 的类型,在给出接收者和方法名的前提下,Rust 可以明确地计算出方法是仅仅读取(&self),做出修改(&mut self)或者是获取所有权(self).

### 关联函数

impl 块的另一个有用的功能是:允许在 impl 块中定义不以 self 作为参数的函数.关联函数经常被用作返回一个结构体新实例的构造函数.使用结构体名和 `::` 语法来调用这个关联函数.方法位于结构体的命名空间中. `::` 语法用于关联函数和模块创建的命名空间
